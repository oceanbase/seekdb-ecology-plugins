---
slug: /get_sql-mysql
---

# GET_SQL

The `GET_SQL` function returns the SQL statement that was actually executed, as a string.

## Syntax

```sql
FUNCTION GET_SQL (IN table_name VARCHAR(65535),
                  IN search_params LONGTEXT)
RETURN LONGTEXT;
```

## Parameters

| Parameter | Description | Required |
| --- | --- | --- |
| table_name | The name of the table. Heap tables and tables without a primary key are supported. | Yes |
| search_params | Search parameters, provided as a JSON-formatted string. | Yes |

## `search_params` structure

`search_params` is a JSON-formatted string. This section describes its structure. Read it together with the parameter descriptions and examples below.

### Notation

This section explains the BNF notation used in the syntax definitions:

1. Optional elements

   * In BNF, `[ ]` indicates an optional, repeatable element. For example, `param_list = param [, param]*` means `param_list` can contain one or more `param` items.
   * In `rank_feature` and `rank_expression`, `[ ]` also indicates optional sub-parameters.
   * `[, "boost" : boost_value]` means the `boost` sub-parameter is optional. All `boost` sub-parameters are optional.

2. Arrays
   * In JSON, `[ ]` indicates an array, for example, `[condition_list]`.

3. Alternatives
   * `|` indicates alternatives. For example, `param = "query" | "knn"` means `param` can be `"query"` or `"knn"`.

4. Repetition
   * `*` indicates repetition zero or more times. For example, `param_list = param [, param]*` means `param_list` can contain one or more `param` items.

5. JSON formatting requirements
   * All JSON field names and string values must be enclosed in double quotes.
   * Numeric values must not be enclosed in double quotes.

### Syntax definition

This section describes the structure of `search_params`. For parameter details, see the table in the next section.

#### Top-level structure

```sql
-- Top-level keyword parameters
search_params = '{param_list}'
    param_list = param [, param]*
    -- query and knn are used for full-text/scalar retrieval and vector retrieval, respectively.
    -- You must specify at least one of them. For hybrid retrieval, specify both.
    param = "query"     : {query_expression}
          | "knn"       : {knn_expression}
          | "rank"      : {rank_expression}
          | "_source"   : [field_list]
          | "from"      : number
          | "size"      : number
          | "es_mode"   : boolean
```

#### Query expression

```sql
query_expression = bool_query | single_term

-- bool_query structure
bool_query = "bool" : {bool_condition_list}
    bool_condition_list = bool_condition [, bool_condition]*
    -- boost is optional
    bool_condition = "must"    : [condition_list]
                  | "should"   : [condition_list]
                  | "must_not" : [condition_list]
                  | "filter"   : [condition_list]
                  | "boost"    : boost_value
    -- Nested bool_query is supported
    condition_list = query_expression [, query_expression]*
```

#### Single-term query

```sql
single_term = range_query | match_query | term_query | terms_query | query_string | multi_match | rank_feature

-- range_query structure
range_query = "range" : {"field_name" : {range_condition_list}}
    range_condition_list = range_condition [, range_condition]*
    -- boost is optional
    range_condition = "gte"    : number
                    | "gt"     : number
                    | "lte"    : number
                    | "lt"     : number
                    | "boost"  : boost_value

-- match_query structure
match_query = "match" : {"field_name" : {match_condition}}
    -- boost is optional
    match_condition = "query" : "string_value" [, "boost" : boost_value]

-- term_query structure
term_query = "term" : {term_condition_list}
    term_condition_list = term_condition [, term_condition]*
    term_condition = "field_name" : scalar_value
                   | "field_name" : term_value_object
    -- boost is optional
    term_value_object = "value" : scalar_value [, "boost" : boost_value]

-- terms_query structure
terms_query = "terms" : {terms_condition_list}
    terms_condition_list = terms_condition [, terms_condition]*
    terms_condition = "field_name" : [scalar_value_list]
                    | "boost"      : boost_value
    scalar_value_list = scalar_value [, scalar_value]*

-- Full-text search supports query_string and multi_match
query_string = "query_string" : {query_string_condition}
-- fields and query are required
    query_string_condition = "fields" : [field_weight_list]
                           | "query"  : "string_value"
                           | "boost"  : boost_value
                           | "type"   : ("best_fields" | "cross_fields" | "most_fields" | "phrase")
                           | "default_operator" : ("AND" | "OR")
                           | "minimum_should_match" : number
    field_weight_list = field_weight [, field_weight]*
    -- No spaces are allowed between field_name, ^, and number
    field_weight = "field_name[^number]"

-- multi_match structure
multi_match = "multi_match" : {multi_match_condition}
-- fields and query are required
    multi_match_condition = "fields" : [field_weight_list]
                         | "query"  : "string_value"
                         | "boost"  : boost_value
                         | "type"   : ("best_fields" | "cross_fields" | "most_fields" | "phrase")
                         | "operator" : ("AND" | "OR")
                         | "minimum_should_match" : number
    field_weight_list = field_weight [, field_weight]*
    -- No spaces are allowed between field_name, ^, and number
    field_weight = "field_name[^number]"

-- Feature-based ranking
rank_feature = "rank_feature" : {"field_name" : {rank_algorithm}}
    rank_algorithm = "saturation" : {"pivot" : number[, "positive_score_impact" : boolean]}
                   | "sigmoid"    : {"pivot" : number, "exponent" : number[, "positive_score_impact" : boolean]}
                   | "log"        : {"scaling_factor" : number[, "positive_score_impact" : boolean]}
                   | "linear"     : {["positive_score_impact" : boolean]}
```

#### Vector retrieval

```sql
-- Single vector retrieval
knn_expression = "knn" : {knn_condition_list}
    knn_condition_list = knn_condition [, knn_condition]*
    -- field, k, and query_vector are required
    knn_condition = "field"         : "field_name"
                 | "k"             : number
                 | "query_vector"  : [vector_values]
                 | "filter"        : [condition_list]
                 | "similarity"    : number
                 | "boost"         : boost_value
    vector_values = float [, float]*
    condition_list = query_expression [, query_expression]*

-- Multi-vector retrieval
-- The [ ] around [multi_knn_condition_list] is part of the required structure and must not be changed.
multi_knn_expression = "knn" : [multi_knn_condition_list]
    -- The [ ] around [multi_knn_condition] indicates it is optional.
    multi_knn_condition_list = {multi_knn_condition} [, {multi_knn_condition}]*
    -- field, k, and query_vector are required
    multi_knn_condition = "field"         : "field_name"
                        | "k"             : number
                        | "query_vector"  : [vector_values]
                        | "filter"        : [condition_list]
                        | "similarity"    : number
                        | "boost"         : boost_value

-- rank_expression structure
rank_expression = "rank" : {rank_strategy}
    rank_strategy = "rrf" : {rrf_params}
    rrf_params = "rank_window_size" : number [, "rank_constant" : number]
```

#### Basic types

```sql
-- Basic types
field_name = "string_value"
field_list = field_name [, field_name]*
number = integer | decimal
boost_value = integer | float  -- boost must be >= 0
boolean = true | false
scalar_value = "string_value" | number | boolean
```

### Parameter details

The following table describes the parameters in `search_params`.

<table>
  <thead>
    <tr>
      <th>Expression type</th>
      <th>Parameter</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
      <td rowspan="8">Top-level keyword parameters</td>
    </tr>
    <tr>
      <td>query</td>
      <td>Used for full-text search. Can be used alone, or together with <code>knn</code> for hybrid search.</td>
    </tr>
    <tr>
      <td>knn</td>
      <td>Used for single- or multi-vector retrieval. Can be used alone, or together with <code>query</code> for hybrid search.</td>
    </tr>
    <tr>
      <td>rank (optional)</td>
      <td>Specifies the ranking strategy for hybrid search. The RRF (Reciprocal Rank Fusion) algorithm is supported.</td>
    </tr>
    <tr>
      <td>_source (optional)</td>
      <td>Specifies which columns to include in the response. If not specified, all user-defined columns in the table are returned.</td>
    </tr>
    <tr>
      <td>from (optional)</td>
      <td>Specifies the starting offset in the result set. If not specified, results are returned starting from the first row. Use it together with <code>size</code>.</td>
    </tr>
    <tr>
      <td>size (optional)</td>
      <td>Limits the number of rows returned. If omitted, no limit is applied.</td>
    </tr>
    <tr>
      <td>es_mode</td>
      <td>Specifies whether to convert full-text search into the ESQL new syntax. The default is <code>false</code>.</td>
    </tr>
    <tr>
      <td rowspan="5">bool</td>
      <td>must</td>
      <td>Must match and contributes to the score. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>should</td>
      <td>Should match (similar to OR) and contributes to the score. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>must_not</td>
      <td>Must not match and does not contribute to the score. It is converted to a NOT expression; multiple clauses inside <code>must_not</code> are combined with AND. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>filter</td>
      <td>Must match and does not contribute to the score. It is converted to an AND expression. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>boost (optional)</td>
      <td>Query weight. For details, see <em>Boost parameter</em> below.</td>
    </tr>
    <tr>
      <td rowspan="4">rank_feature (scoring parameters)</td>
      <td>pivot</td>
      <td>A required scoring parameter for <code>saturation</code> and <code>sigmoid</code>. The default is the geometric mean of the values in the column.</td>
    </tr>
    <tr>
      <td>positive_score_impact (optional)</td>
      <td>Controls whether the field has a positive or negative impact on the final relevance score.</td>
    </tr>
    <tr>
      <td>scaling_factor</td>
      <td>A required parameter for the <code>log</code> scoring formula.</td>
    </tr>
    <tr>
      <td>exponent</td>
      <td>A required parameter for the <code>sigmoid</code> scoring formula.</td>
    </tr>
    <tr>
      <td rowspan="4">rank_feature (scoring algorithms)</td>
      <td>saturation</td>
      <td>Default scoring algorithm<ul><li>Positive impact: <code>S / (S + pivot)</code></li><li>Negative impact: <code>pivot / (S + pivot)</code></li><li><code>S</code> is the value of the <code>rank_feature</code> column.</li></ul></td>
    </tr>
    <tr>
      <td>sigmoid</td>
      <td><ul><li>Similar to <code>saturation</code> but adds the exponent parameter <code>e</code>.</li><li><code>S^e / (S^e + pivot^e)</code></li></ul></td>
    </tr>
    <tr>
      <td>log</td>
      <td><ul><li>Only supports positive impact.</li><li>Formula: <code>ln(scaling_factor + S)</code></li><li><code>S</code> is the value of the <code>rank_feature</code> column.</li><li><code>scaling_factor</code> must be specified in the request.</li></ul></td>
    </tr>
    <tr>
      <td>linear</td>
      <td><ul><li>Positive impact score: <code>S</code></li><li>Negative impact score: <code>1/S</code></li><li><code>S</code> is the value of the <code>rank_feature</code> column.</li></ul></td>
    </tr>
    <tr>
      <td rowspan="14">single_term (single-term retrieval)</td>
    </tr>
    <tr>
      <td>range</td>
      <td>Range query. Use with <code>gte</code>, <code>gt</code>, <code>lte</code>, <code>lt</code>, and <code>boost</code>. <code>fieldname</code> is required.</td>
    </tr>
    <tr>
      <td>match</td>
      <td>Fuzzy match. Converted to a SQL <code>match</code> expression. Use with <code>boost</code>.</td>
    </tr>
    <tr>
      <td>term</td>
      <td>Exact match. Supports scalar values such as strings, numbers, and booleans. Converted to a SQL <code>=</code> expression. Use with <code>boost</code>.</td>
    </tr>
    <tr>
      <td>terms</td>
      <td>Exact match against any value in a set. Supports arrays of scalar values (strings, numbers, booleans, etc.). Converted to a SQL <code>IN</code> expression. Use with <code>boost</code>.</td>
    </tr>
    <tr>
      <td>query_string</td>
      <td>Full-text match. Converted into a combination of multiple SQL <code>match</code> expressions.</td>
    </tr>
    <tr>
      <td>multi_match</td>
      <td>Full-text match. Converted into a combination of multiple SQL <code>match</code> expressions. Similar to <code>query_string</code>, but it does not support weights for a single keyword.</td>
    </tr>
    <tr>
      <td>fields</td>
      <td>A list of fields used for full-text retrieval. You can specify a weight for each field.</td>
    </tr>
    <tr>
      <td>query</td>
      <td>A list of query terms. You can specify a weight for each term.</td>
    </tr>
    <tr>
      <td>minimum_should_match (optional)</td>
      <td>Controls how many conditions in <code>should</code> or <code>query_string</code> must match. If omitted, the default is <code>1</code>. Note: If <code>must</code> or <code>filter</code> exists in the bool expression and this parameter is omitted, the default becomes <code>0</code> (meaning none of the <code>should</code> clauses must match).</td>
    </tr>
    <tr>
      <td>boost (optional)</td>
      <td>Query weight. For details, see <em>Boost parameter</em> below.</td>
    </tr>
    <tr>
      <td>type (optional)</td>
      <td>Match mode. This release supports <code>best_fields</code>, <code>cross_fields</code>, <code>most_fields</code>, and <code>phrase</code>. If omitted, the default is <code>best_fields</code>.</td>
    </tr>
    <tr>
      <td>default_operator (optional)</td>
      <td>A sub-field of <code>query_string</code>. Specifies how multiple query terms are combined.</td>
    </tr>
    <tr>
      <td>operator (optional)</td>
      <td>A sub-field of <code>multi_match</code>. Specifies how multiple query terms are combined.</td>
    </tr>
    <tr>
      <td rowspan="7">knn (vector retrieval)</td>
    </tr>
    <tr>
      <td>field</td>
      <td>The vector field used for retrieval.</td>
    </tr>
    <tr>
      <td>k</td>
      <td>The number of rows to return from vector retrieval.</td>
    </tr>
    <tr>
      <td>query_vector</td>
      <td>The query vector.</td>
    </tr>
    <tr>
      <td>filter (optional)</td>
      <td>Filter conditions.</td>
    </tr>
    <tr>
      <td>similarity (optional)</td>
      <td>A filter condition based on vector distance.</td>
    </tr>
    <tr>
      <td>boost (optional)</td>
      <td>Query weight. For details, see <em>Boost parameter</em> below.</td>
    </tr>
    <tr>
      <td rowspan="3">rank (RRF ranking strategy)</td>
      <td>rrf</td>
      <td>RRF (Reciprocal Rank Fusion) ranking strategy. Used in hybrid search to fuse and re-rank results from multiple queries.</td>
    </tr>
    <tr>
      <td>rank_window_size (optional)</td>
      <td>Specifies the size of the per-query result window. A larger value generally improves relevance but increases overhead. The final ranked result set is truncated to the <code>size</code> specified in the request.<br/><br/>The value of <code>rank_window_size</code> must satisfy:<ul><li>Greater than or equal to <code>size</code></li><li>Greater than or equal to <code>1</code></li></ul>The default is the value of <code>size</code>.</td>
    </tr>
    <tr>
      <td>rank_constant (optional)</td>
      <td>Controls how much lower-ranked documents in each per-query result set influence the final ranking. A larger value gives more influence to lower-ranked documents. The default is 60.</td>
    </tr>
  </tbody>
</table>

#### Boost parameter

The `boost` parameter specifies the weight of a query condition in the final relevance calculation. The value must be greater than or equal to `0`. If omitted, the default is `1`.

In the syntax above, `boost` is supported by `bool`, `single_term` (except `rank_feature`), and both single- and multi-vector retrieval (`knn`). The following examples show how `boost` can be used:

1. Query-level boost

    Assigns a weight to the entire query condition. For example:

    ```shell
    {
      "bool": {
        "must": [{"term": {"category": "Gaming"}}],
        "boost": 2.0  // Weight of the entire bool query
      }
    }
    ```

2. Field-level boost

    Assigns a weight to a query on a specific field. For example:

    ```shell
    {
      "query_string": {
        "fields": ["product_name", "description"],
        "query": "gaming keyboard",
        "boost": 1.5  // Weight of the entire query_string query
      }
    }
    ```

3. Value-level boost

    Assigns a weight to a specific match value (supported by match, term, and terms queries). For example:

    ```shell
    {
      "match" : {
        "product_name":  {
        "query" : "gaming keyboard",
        "boost" : 1.5
        }
      }
    }
    ```

4. Field weight syntax

    In query_string and multi_match, you can use the `field_name^weight` syntax. For example:

    ```shell
    {
      "query_string": {
        "fields": ["product_name^2.0", "description^1.0"],
        "query": "gaming"
      }
    }
    ```

5. Vector retrieval boost

    In single- and multi-vector retrieval, each vector field can specify its own `boost` weight:

    Single vector retrieval:

    ```shell
    {
      "knn": {
        "field": "vector",
        "k": 5,
        "query_vector": [1, 2, 3],
        "boost": 1.5  // Weight for this vector field
      }
    }
    ```

    Multi-vector retrieval:

    ```shell
    {
      "knn": [{
        "field": "c2",
        "k": 5,
        "query_vector": [1, 2, 3],
        "boost": 2.0  // Weight for the c2 vector field
      }, {
        "field": "c4",
        "k": 5,
        "query_vector": [1, 2, 3],
        "boost": 1.0  // Weight for the c4 vector field
      }]
    }
    ```

## Examples

Create a table that includes one vector column with a vector index and two `varchar` columns with full-text indexes:

```sql
CREATE TABLE doc_table(c1 INT, vector VECTOR(3), query VARCHAR(255), content VARCHAR(255),
VECTOR INDEX idx1(vector) WITH (distance=l2, type=hnsw, lib=vsag), FULLTEXT INDEX idx2(query),
FULLTEXT INDEX idx3(content));
```

Set the search parameters:

```sql
SET @parm = '{
      "query": {
        "bool": {
          "should": [
            {"match": {"query": "hi hello"}},
            {"match": { "content": "oceanbase mysql" }}
          ],
          "filter": [
            {"term": { "content" : "postgres" }}
          ]
        }
      },
       "knn" : {
          "field": "vector",
          "k": 5,
          "query_vector": [1,2,3]
      },
      "_source" : ["query", "content", "_keyword_score", "_semantic_score"]
    }';
```

Run the query to return the SQL statement:

```sql
SELECT DBMS_HYBRID_SEARCH.GET_SQL('doc_table', @parm);
```

The return result is as follows:

```sql
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| dbms_hybrid_search.get_sql('doc_table', @parm)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| SELECT query, content, _keyword_score, _semantic_score, (ifnull(_fts._keyword_score, 0) + ifnull(_vs._semantic_score, 0)) as _score FROM ((SELECT /*+ opt_param('hidden_column_visible', 'true') union_merge( doc_table idx2 idx3)*/__pk_increment, (match(query) against('hi hello' in boolean mode) + match(content) against('oceanbase mysql' in boolean mode)) as _keyword_score FROM wxj.doc_table WHERE (content = 'postgres') ORDER BY _keyword_score DESC) _fts right join (SELECT /*+ opt_param('hidden_column_visible', 'true') */l2_distance(vector, '[1, 2, 3]') as _distance, __pk_increment, query, content, round((1 / (1 + l2_distance(vector, '[1, 2, 3]'))), 8) as _semantic_score FROM wxj.doc_table ORDER BY _distance APPROXIMATE LIMIT 5) _vs on (_fts.__pk_increment = _vs.__pk_increment)) ORDER BY _score DESC |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
```

## References

* [DBMS_HYBRID_SEARCH subprograms overview](100.dbms-hybrid-search-overview.md)
* [SEARCH](200.search.md)
