---
slug: /search-mysql
---

# SEARCH

The `SEARCH` function returns search results in JSON format. Results are ordered by relevance.

## Syntax

```sql
FUNCTION SEARCH (IN table_name VARCHAR(65535),
                 IN search_params LONGTEXT)
RETURN JSON;
```

## Parameters

| Parameter | Description | Required |
| --- | --- | --- |
| table_name | The name of the table. Heap tables and tables without a primary key are supported. | Yes |
| search_params | Search parameters, provided as a JSON-formatted string. | Yes |

## `search_params` structure

`search_params` is a JSON-formatted string. This section describes its structure. Read it together with the parameter descriptions and examples below.

### Notation

This section explains the BNF notation used in the syntax definitions:

1. Optional elements

   * In BNF, `[ ]` indicates an optional, repeatable element. For example, `param_list = param [, param]*` means `param_list` can contain one or more `param` items.
   * In `rank_feature` and `rank_expression`, `[ ]` also indicates optional sub-parameters.
   * `[, "boost" : boost_value]` means the `boost` sub-parameter is optional. All `boost` sub-parameters are optional.

2. Arrays
   * In JSON, `[ ]` indicates an array, for example, `[condition_list]`.

3. Alternatives
   * `|` indicates alternatives. For example, `param = "query" | "knn"` means `param` can be `"query"` or `"knn"`.

4. Repetition
   * `*` indicates repetition zero or more times. For example, `param_list = param [, param]*` means `param_list` can contain one or more `param` items.

5. JSON formatting requirements
   * All JSON field names and string values must be enclosed in double quotes.
   * Numeric values must not be enclosed in double quotes.

### Syntax definition

This section describes the structure of `search_params`. For parameter details, see the table in the next section.

#### Top-level structure

```sql
-- Top-level keyword parameters
search_params = '{param_list}'
    param_list = param [, param]*
    -- query and knn are used for full-text/scalar retrieval and vector retrieval, respectively.
    -- You must specify at least one of them. For hybrid retrieval, specify both.
    param = "query"     : {query_expression}
          | "knn"       : {knn_expression}
          | "rank"      : {rank_expression}
          | "_source"   : [field_list]
          | "from"      : number
          | "size"      : number
          | "es_mode"   : boolean
```

#### Query expression

```sql
query_expression = bool_query | single_term

-- bool_query structure
bool_query = "bool" : {bool_condition_list}
    bool_condition_list = bool_condition [, bool_condition]*
    -- boost is optional
    bool_condition = "must"    : [condition_list]
                  | "should"   : [condition_list]
                  | "must_not" : [condition_list]
                  | "filter"   : [condition_list]
                  | "boost"    : boost_value
    -- Nested bool_query is supported
    condition_list = query_expression [, query_expression]*
```

#### Single-term query

```sql
single_term = range_query | match_query | term_query | terms_query | query_string | multi_match | rank_feature

-- range_query structure
range_query = "range" : {"field_name" : {range_condition_list}}
    range_condition_list = range_condition [, range_condition]*
    -- boost is optional
    range_condition = "gte"    : number
                    | "gt"     : number
                    | "lte"    : number
                    | "lt"     : number
                    | "boost"  : boost_value

-- match_query structure
match_query = "match" : {"field_name" : {match_condition}}
    -- boost is optional
    match_condition = "query" : "string_value" [, "boost" : boost_value]

-- term_query structure
term_query = "term" : {term_condition_list}
    term_condition_list = term_condition [, term_condition]*
    term_condition = "field_name" : scalar_value
                   | "field_name" : term_value_object
    -- boost is optional
    term_value_object = "value" : scalar_value [, "boost" : boost_value]

-- terms_query structure
terms_query = "terms" : {terms_condition_list}
    terms_condition_list = terms_condition [, terms_condition]*
    terms_condition = "field_name" : [scalar_value_list]
                    | "boost"      : boost_value
    scalar_value_list = scalar_value [, scalar_value]*

-- Full-text search supports query_string and multi_match
query_string = "query_string" : {query_string_condition}
-- fields and query are required
    query_string_condition = "fields" : [field_weight_list]
                           | "query"  : "string_value"
                           | "boost"  : boost_value
                           | "type"   : ("best_fields" | "cross_fields" | "most_fields" | "phrase")
                           | "default_operator" : ("AND" | "OR")
                           | "minimum_should_match" : number
    field_weight_list = field_weight [, field_weight]*
    -- No spaces are allowed between field_name, ^, and number
    field_weight = "field_name[^number]"

-- multi_match structure
multi_match = "multi_match" : {multi_match_condition}
-- fields and query are required
    multi_match_condition = "fields" : [field_weight_list]
                         | "query"  : "string_value"
                         | "boost"  : boost_value
                         | "type"   : ("best_fields" | "cross_fields" | "most_fields" | "phrase")
                         | "operator" : ("AND" | "OR")
                         | "minimum_should_match" : number
    field_weight_list = field_weight [, field_weight]*
    -- No spaces are allowed between field_name, ^, and number
    field_weight = "field_name[^number]"

-- Feature-based ranking
rank_feature = "rank_feature" : {"field_name" : {rank_algorithm}}
    rank_algorithm = "saturation" : {"pivot" : number[, "positive_score_impact" : boolean]}
                   | "sigmoid"    : {"pivot" : number, "exponent" : number[, "positive_score_impact" : boolean]}
                   | "log"        : {"scaling_factor" : number[, "positive_score_impact" : boolean]}
                   | "linear"     : {["positive_score_impact" : boolean]}
```

#### Vector retrieval

```sql
-- Single vector retrieval
knn_expression = "knn" : {knn_condition_list}
    knn_condition_list = knn_condition [, knn_condition]*
    -- field, k, and query_vector are required
    knn_condition = "field"         : "field_name"
                 | "k"             : number
                 | "query_vector"  : [vector_values]
                 | "filter"        : [condition_list]
                 | "similarity"    : number
                 | "boost"         : boost_value
    vector_values = float [, float]*
    condition_list = query_expression [, query_expression]*

-- Multi-vector retrieval
-- The [ ] around [multi_knn_condition_list] is part of the required structure and must not be changed.
multi_knn_expression = "knn" : [multi_knn_condition_list]
    -- The [ ] around [multi_knn_condition] indicates it is optional.
    multi_knn_condition_list = {multi_knn_condition} [, {multi_knn_condition}]*
    -- field, k, and query_vector are required
    multi_knn_condition = "field"         : "field_name"
                        | "k"             : number
                        | "query_vector"  : [vector_values]
                        | "filter"        : [condition_list]
                        | "similarity"    : number
                        | "boost"         : boost_value
    vector_values = float [, float]*
    condition_list = query_expression [, query_expression]*

-- rank_expression structure
rank_expression = "rank" : {rank_strategy}
    rank_strategy = "rrf" : {rrf_params}
    rrf_params = "rank_window_size" : number [, "rank_constant" : number]
```

#### Basic types

```sql
-- Basic types
field_name = "string_value"
field_list = field_name [, field_name]*
number = integer | decimal
boost_value = integer | float  -- boost must be >= 0
boolean = true | false
scalar_value = "string_value" | number | boolean
```

### Parameter details

The following table describes the parameters in `search_params`.

<table>
  <thead>
    <tr>
      <th>Expression type</th>
      <th>Parameter</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
      <tr>
      <td rowspan="8">Top-level keyword parameters</td>
    </tr>
    <tr>
      <td>query</td>
      <td>Used for full-text search. Can be used alone, or together with <code>knn</code> for hybrid search.</td>
    </tr>
    <tr>
      <td>knn</td>
      <td>Used for single- or multi-vector retrieval. Can be used alone, or together with <code>query</code> for hybrid search.</td>
    </tr>
    <tr>
      <td>rank (optional)</td>
      <td>Specifies the ranking strategy for hybrid search. The RRF (Reciprocal Rank Fusion) algorithm is supported.</td>
    </tr>
    <tr>
      <td>_source (optional)</td>
      <td>Specifies which columns to include in the response. If not specified, all user-defined columns in the table are returned.</td>
    </tr>
    <tr>
      <td>from (optional)</td>
      <td>Specifies the starting offset in the result set. If not specified, results are returned starting from the first row. Use it together with <code>size</code>.</td>
    </tr>
    <tr>
      <td>size (optional)</td>
      <td>Limits the number of rows returned. If not specified, the default is <code>10</code>.</td>
    </tr>
    <tr>
      <td>es_mode</td>
      <td>Specifies whether to convert full-text search into the ESQL new syntax. The default is <code>false</code>.</td>
    </tr>
    <tr>
      <td rowspan="5">bool</td>
      <td>must</td>
      <td>Must match and contributes to the score. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>should</td>
      <td>Should match (similar to OR) and contributes to the score. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>must_not</td>
      <td>Must not match and does not contribute to the score. It is converted to a NOT expression; multiple clauses inside <code>must_not</code> are combined with AND. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>filter</td>
      <td>Must match and does not contribute to the score. It is converted to an AND expression. If you need boolean logic inside, nest a bool expression. Multiple conditions in a bool expression are combined with AND by default.</td>
    </tr>
    <tr>
      <td>boost (optional)</td>
      <td>Query weight. For details, see <em>Boost parameter</em> below.</td>
    </tr>
    <tr>
      <td rowspan="4">rank_feature (scoring parameters)</td>
      <td>pivot</td>
      <td>A required scoring parameter for <code>saturation</code> and <code>sigmoid</code>. The default is the geometric mean of the values in the column.</td>
    </tr>
    <tr>
      <td>positive_score_impact (optional)</td>
      <td>Controls whether the field has a positive or negative impact on the final relevance score.</td>
    </tr>
    <tr>
      <td>scaling_factor</td>
      <td>A required parameter for the <code>log</code> scoring formula.</td>
    </tr>
    <tr>
      <td>exponent</td>
      <td>A required parameter for the <code>sigmoid</code> scoring formula.</td>
    </tr>
    <tr>
      <td rowspan="4">rank_feature (scoring algorithms)</td>
      <td>saturation</td>
      <td>Default scoring algorithm<ul><li>Positive impact: <code>S / (S + pivot)</code></li><li>Negative impact: <code>pivot / (S + pivot)</code></li><li><code>S</code> is the value of the <code>rank_feature</code> column.</li></ul></td>
    </tr>
    <tr>
      <td>sigmoid</td>
      <td><ul><li>Similar to <code>saturation</code> but adds the exponent parameter <code>e</code>.</li><li><code>S^e / (S^e + pivot^e)</code></li></ul></td>
    </tr>
    <tr>
      <td>log</td>
      <td><ul><li>Only supports positive impact.</li><li>Formula: <code>ln(scaling_factor + S)</code></li><li><code>S</code> is the value of the <code>rank_feature</code> column.</li><li><code>scaling_factor</code> must be specified in the request.</li></ul></td>
    </tr>
    <tr>
      <td>linear</td>
      <td><ul><li>Positive impact score: <code>S</code></li><li>Negative impact score: <code>1/S</code></li><li><code>S</code> is the value of the <code>rank_feature</code> column.</li></ul></td>
    </tr>
    <tr>
      <td rowspan="14">single_term (single-term retrieval)</td>
    </tr>
    <tr>
      <td>range</td>
      <td>Range query. Use with <code>gte</code>, <code>gt</code>, <code>lte</code>, <code>lt</code>, and <code>boost</code>. <code>fieldname</code> is required.</td>
    </tr>
    <tr>
      <td>match</td>
      <td>Fuzzy match. Converted to a SQL <code>match</code> expression. Use with <code>boost</code>.</td>
    </tr>
    <tr>
      <td>term</td>
      <td>Exact match. Supports scalar values such as strings, numbers, and booleans. Converted to a SQL <code>=</code> expression. Use with <code>boost</code>.</td>
    </tr>
    <tr>
      <td>terms</td>
      <td>Exact match against any value in a set. Supports arrays of scalar values (strings, numbers, booleans, etc.). Converted to a SQL <code>IN</code> expression. Use with <code>boost</code>.</td>
    </tr>
    <tr>
      <td>query_string</td>
      <td>Full-text match. Converted into a combination of multiple SQL <code>match</code> expressions.</td>
    </tr>
    <tr>
      <td>multi_match</td>
      <td>Full-text match. Converted into a combination of multiple SQL <code>match</code> expressions. Similar to <code>query_string</code>, but it does not support weights for a single keyword.</td>
    </tr>
    <tr>
      <td>fields</td>
      <td>A list of fields used for full-text retrieval. You can specify a weight for each field.</td>
    </tr>
    <tr>
      <td>query</td>
      <td>A list of query terms. You can specify a weight for each term.</td>
    </tr>
    <tr>
      <td>minimum_should_match (optional)</td>
      <td>Controls how many conditions in <code>should</code> or <code>query_string</code> must match. If omitted, the default is <code>1</code>. Note: If <code>must</code> or <code>filter</code> exists in the bool expression and this parameter is omitted, the default becomes <code>0</code> (meaning none of the <code>should</code> clauses must match).</td>
    </tr>
    <tr>
      <td>boost (optional)</td>
      <td>Query weight. For details, see <em>Boost parameter</em> below.</td>
    </tr>
    <tr>
      <td>type (optional)</td>
      <td>Match mode. This release supports <code>best_fields</code>, <code>cross_fields</code>, <code>most_fields</code>, and <code>phrase</code>. If omitted, the default is <code>best_fields</code>.</td>
    </tr>
    <tr>
      <td>default_operator (optional)</td>
      <td>A sub-field of <code>query_string</code>. Specifies how multiple query terms are combined.</td>
    </tr>
    <tr>
      <td>operator (optional)</td>
      <td>A sub-field of <code>multi_match</code>. Specifies how multiple query terms are combined.</td>
    </tr>
    <tr>
      <td rowspan="7">knn (vector retrieval)</td>
    </tr>
    <tr>
      <td>field</td>
      <td>The vector field used for retrieval.</td>
    </tr>
    <tr>
      <td>k</td>
      <td>The number of rows to return from vector retrieval.</td>
    </tr>
    <tr>
      <td>query_vector</td>
      <td>The query vector.</td>
    </tr>
    <tr>
      <td>filter (optional)</td>
      <td>Filter conditions.</td>
    </tr>
    <tr>
      <td>similarity (optional)</td>
      <td>A filter condition based on vector distance.</td>
    </tr>
    <tr>
      <td>boost (optional)</td>
      <td>Query weight. For details, see <em>Boost parameter</em> below.</td>
    </tr>
    <tr>
      <td rowspan="3">rank (RRF ranking strategy)</td>
      <td>rrf</td>
      <td>RRF (Reciprocal Rank Fusion) ranking strategy. Used in hybrid search to fuse and re-rank results from multiple queries.</td>
    </tr>
    <tr>
      <td>rank_window_size (optional)</td>
      <td>Specifies the size of the per-query result window. A larger value generally improves relevance but increases overhead. The final ranked result set is truncated to the <code>size</code> specified in the request.<br/><br/>The value of <code>rank_window_size</code> must satisfy:<ul><li>Greater than or equal to <code>size</code></li><li>Greater than or equal to <code>1</code></li></ul>The default is the value of <code>size</code>.</td>
    </tr>
    <tr>
      <td>rank_constant (optional)</td>
      <td>Controls how much lower-ranked documents in each per-query result set influence the final ranking. A larger value gives more influence to lower-ranked documents. The default is 60.</td>
    </tr>
  </tbody>
</table>

#### Boost parameter

The `boost` parameter specifies the weight of a query condition in the final relevance calculation. The value must be greater than or equal to `0`. If omitted, the default is `1`.

In the syntax above, `boost` is supported by `bool`, `single_term` (except `rank_feature`), and both single- and multi-vector retrieval (`knn`). The following examples show how `boost` can be used:

1. Query-level boost

    Assigns a weight to the entire query condition. For example:

    ```shell
    {
      "bool": {
        "must": [{"term": {"category": "Gaming"}}],
        "boost": 2.0  // Weight of the entire bool query
      }
    }
    ```

2. Field-level boost

    Assigns a weight to a query on a specific field. For example:

    ```shell
    {
      "query_string": {
        "fields": ["product_name", "description"],
        "query": "gaming keyboard",
        "boost": 1.5  // Weight of the entire query_string query
      }
    }
    ```

3. Value-level boost

    Assigns a weight to a specific match value (supported by match, term, and terms queries). For example:

    ```shell
    {
      "match" : {
        "product_name":  {
        "query" : "gaming keyboard",
        "boost" : 1.5
        }
      }
    }
    ```

4. Field weight syntax

    In query_string and multi_match, you can use the `field_name^weight` syntax. For example:

    ```shell
    {
      "query_string": {
        "fields": ["product_name^2.0", "description^1.0"],
        "query": "gaming"
      }
    }
    ```

5. Vector retrieval boost

    In single- and multi-vector retrieval, each vector field can specify its own `boost` weight:

    Single vector retrieval:

    ```shell
    {
      "knn": {
        "field": "vector",
        "k": 5,
        "query_vector": [1, 2, 3],
        "boost": 1.5  // Weight for this vector field
      }
    }
    ```

    Multi-vector retrieval:

    ```shell
    {
      "knn": [{
        "field": "c2",
        "k": 5,
        "query_vector": [1, 2, 3],
        "boost": 2.0  // Weight for the c2 vector field
      }, {
        "field": "c4",
        "k": 5,
        "query_vector": [1, 2, 3],
        "boost": 1.0  // Weight for the c4 vector field
      }]
    }
    ```

## Examples

### Basic scalar search

Create the example table `products`:

```sql
CREATE TABLE products (
  `product_id` varchar(50) DEFAULT NULL,
  `product_name` varchar(255) DEFAULT NULL,
  `description` text DEFAULT NULL,
  `brand` varchar(100) DEFAULT NULL,
  `category` varchar(100) DEFAULT NULL,
  `tags` varchar(255) DEFAULT NULL,
  `price` decimal(10,2) DEFAULT NULL,
  `stock_quantity` int(11) DEFAULT NULL,
  `release_date` datetime DEFAULT NULL,
  `is_on_sale` tinyint(1) DEFAULT NULL,
  `vec` VECTOR(4) DEFAULT NULL
);
```

Insert data:

```sql
INSERT INTO products VALUES
('prod-004', 'Gamer-Pro Mechanical Keyboard', 'A responsive mechanical keyboard with customizable RGB lighting for the ultimate gaming experience.',
 'GamerZone', 'Gaming', 'best-seller,gaming-gear,rgb', 149.00, 100, '2023-07-20 00:00:00.000000', 1, '[0.5,0.1,0.6,0.9]'),

('prod-009', 'Gamer-Pro Headset', 'High-fidelity gaming headset with a noise-cancelling microphone.',
 'GamerZone', 'Gaming', 'best-seller,gaming-gear,audio', 149.00, 100, '2023-07-20 00:00:00.000000', 1, '[0.1,0.9,0.2,0]');
```

Set the search parameters:

```sql
SET @parm = '{
  "query": {
      "bool": {
        "must": [
         {"term": {"brand": "GamerZone"}}
        ]
    }
  }
}';
```

Search for rows where `brand` is `"GamerZone"`:

```sql
SELECT json_pretty(DBMS_HYBRID_SEARCH.SEARCH('products', @parm));
```

The return result is as follows:

```shell
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| json_pretty(DBMS_HYBRID_SEARCH.SEARCH('products', @parm))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [
  {
    "vec": "[0.5,0.1,0.6,0.9]",
    "tags": "best-seller,gaming-gear,rgb",
    "brand": "GamerZone",
    "price": 149.00,
    "_score": 1,
    "category": "Gaming",
    "is_on_sale": 1,
    "product_id": "prod-004",
    "description": "A responsive mechanical keyboard with customizable RGB lighting for the ultimate gaming experience.",
    "product_name": "Gamer-Pro Mechanical Keyboard",
    "release_date": "2023-07-20 00:00:00.000000",
    "stock_quantity": 100
  },
  {
    "vec": "[0.1,0.9,0.2,0]",
    "tags": "best-seller,gaming-gear,audio",
    "brand": "GamerZone",
    "price": 149.00,
    "_score": 1,
    "category": "Gaming",
    "is_on_sale": 1,
    "product_id": "prod-009",
    "description": "High-fidelity gaming headset with a noise-cancelling microphone.",
    "product_name": "Gamer-Pro Headset",
    "release_date": "2023-07-20 00:00:00.000000",
    "stock_quantity": 100
  }
] |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set
```

### Hybrid full-text and vector search

Create an example table that includes a vector column and a vector index, and create full-text indexes on two `varchar` columns:

```sql
CREATE TABLE doc_table(c1 INT, vector VECTOR(3), query VARCHAR(255), content VARCHAR(255), VECTOR INDEX idx1(vector) WITH (distance=l2, type=hnsw, lib=vsag), FULLTEXT INDEX idx2(query), FULLTEXT INDEX idx3(content));
```

Insert data:

```sql
INSERT INTO doc_table VALUES(1, '[1,2,3]', "hello world", "oceanbase Elasticsearch database"),
                            (2, '[1,2,1]', "hello world, what is your name", "oceanbase mysql database"),
                            (3, '[1,1,1]', "hello world, how are you", "oceanbase oracle database"),
                            (4, '[1,3,1]', "real world, where are you from", "postgres oracle database"),
                            (5, '[1,3,2]', "real world, how old are you", "redis oracle database"),
                            (6, '[2,1,1]', "hello world, where are you from", "starrocks oceanbase database");
```

Set the search parameters:

```sql
SET @parm = '{
  "query": {
    "bool": {
      "should": [
        {"match": {"query": "hi hello"}},
        {"match": { "content": "oceanbase mysql" }}
      ]
    }
  },
    "knn" : {
      "field": "vector",
      "k": 5,
      "query_vector": [1,2,3]
  },
  "rank": {
    "rrf": {
      "rank_window_size": 10,
      "rank_constant": 60
    }
  },
  "_source" : ["query", "content"]
}';
```

Run the query:

```sql
SELECT json_pretty(DBMS_HYBRID_SEARCH.SEARCH('doc_table', @parm));
```

The return result is as follows:

```shell
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| json_pretty(DBMS_HYBRID_SEARCH.SEARCH('doc_table', @parm))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [
{
    "query": "hello world",
    "_score": 0.0325,
    "content": "oceanbase Elasticsearch database"
},
{
    "query": "hello world, what is your name",
    "_score": 0.0323,
    "content": "oceanbase mysql database"
},
{
    "query": "hello world, how are you",
    "_score": 0.0315,
    "content": "oceanbase oracle database"
},
{
    "query": "real world, how old are you",
    "_score": 0.0161,
    "content": "redis oracle database"
},
{
    "query": "hello world, where are you from",
    "_score": 0.0159,
    "content": "starrocks oceanbase database"
},
{
    "query": "real world, where are you from",
    "_score": 0.0156,
    "content": "postgres oracle database"
}
] |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set
```

## References

* [DBMS_HYBRID_SEARCH subprograms overview](100.dbms-hybrid-search-overview.md)
* [GET_SQL](300.get_sql.md)
